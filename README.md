# 设计模式
## 高质量代码

设计模式学习笔记和代码示例
## 简单工厂模式
- 注意点
  - 工厂方法中创建对象，代替对象的直接创建（这里指的是使用new方法创建），工厂方法得到的对象称为产品
- 角色
  - 工厂类：生产产品
  - 抽象产品：定义产品的共同接口或者是一个产品抽象父类，在接口/抽象类中定义产品的通用属性和方法

## 模版方法
- 模版方法就是在抽象类中定义一个算法的模版（将算法分解为多个步骤，每一个步骤抽像为一个方法），方法由子类进行实现，并且在抽象类中可以提供一些默认的实现
- 注意点
  - 算法的方法抽象定义需要被final修饰，避免子类对算法的方法进行重写
## 策略模式
- 提供一个算法的接口，算法的具体实现由实现接口的类完成，有一个上下文类，维护接口的引用，并由客户端决定接口的引用是啥，实现程序运行过程中算法的动态改变
- 角色
  - 上下文（维护算法的引用，客户端通过上下文与算法进行交互）
  - 算法的抽象接口
  - 算法的实现类
- 优缺点
  - 优点
    - 程序运行时进行算法的切换
    - 算法的实现和使用进行隔离
    - 符合开闭原则，新增算法的实现无需更改上下文
  - 缺点
    - 如果算法不发生改变不推荐使用策略模式，增加接口和类会让程序更加复杂 
## 观察者模式
- 实现发布订阅机制，发布者状态改变及时通知到所有的订阅者
- 角色
  - 消息发布者
    - 维护一个订阅者的列表
    - 有一个状态值
    - 有一个通知所有订阅者的方法
  - 抽象订阅者
    - 有一个发布者的应用
    - 有一个状态更新的方法
  - 具体订阅者
## 状态模式
- 对象的行为由对象的状态决定
- 角色
  - 状态接口
    - 封装状态对应的行为
  - 状态的实现类
    - 实现特定状态下的行为
  - 上下文（原始对象）
    - 维护状态的引用
## 责任链模式
- 角色
  - 处理器接口
    - nextHandler(Handler handler);
    - handleRequest(Request request);
```java

public static class Builder {
    private Handler head;
    private Handler tail;
    public Builder addHandler(Handler handler) {
        if(head == null) {
            head = tail = handler;
            return this;
        }
        tail.nextHandler(handler);
        tail = handler;
        return this;
    }

    public Handler build() {
        return head;
    }
}
```